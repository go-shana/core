package launcher

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"sync/atomic"
	"syscall"

	"github.com/go-shana/core/errors"
	"github.com/go-shana/core/internal/config"
	"github.com/go-shana/core/internal/lifecycle"
	"github.com/go-shana/core/rpc"
)

// Launch is the entry point for a service.
// This function should be called from the main generated by shana toolchain.
func Launch(createServer func() rpc.Server) (err error) {
	checkLaunched()

	defer func() {
		if err != nil {
			// TODO: use log to instead of fmt.
			fmt.Fprintf(os.Stderr, "launcher: fail to launch the service [err=%v]\n", err)
			os.Exit(1)
		}
	}()
	defer errors.Handle(&err)

	// Create context and set necessary information.
	ctx := context.TODO()

	// Parse command line arguments.
	cli := parseFlags()

	// Load configuration.
	conf := config.New()

	if isFileExists(cli.MainConfig) {
		errors.Check(conf.Load(ctx, cli.MainConfig))
	}

	if cli.ExtConfig != "" && isFileExists(cli.ExtConfig) {
		errors.Check(conf.Load(ctx, cli.ExtConfig))
	}

	// Initialize registered configurations.
	registry := config.DefaultRegistry()
	errors.Check(registry.Decode(ctx, conf.Data()))

	// Initialize connections to stateful services.
	errors.Check(lifecycle.OnConnect.Run(ctx))

	// Run service start-up handlers.
	errors.Check(lifecycle.OnStart.Run(ctx))

	// Release useless resource as early as possible.
	cli = nil
	conf = nil
	lifecycle.OnConnect.Reset()
	lifecycle.OnStart.Reset()

	// Start server.
	server := createServer()
	errors.Check(startServer(ctx, server))

	// Run service shutdown handlers.
	errors.Check(lifecycle.OnShutdown.Run(ctx))

	return
}

var launched atomic.Bool

func checkLaunched() {
	if launched.Load() {
		panic("service is already launched")
	}

	launched.Store(true)
}

func isFileExists(filename string) bool {
	if info, err := os.Stat(filename); err != nil || info.IsDir() {
		return false
	}

	return true
}

func startServer(ctx context.Context, server rpc.Server) (err error) {
	if server == nil {
		return
	}

	defer errors.Handle(&err)

	errChan := make(chan error)
	exitChan := make(chan bool)

	// Handle system signals.
	go func() {
		c := make(chan os.Signal, 2)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)

		select {
		case <-c:
			errChan <- server.Shutdown(ctx)
		case <-exitChan:
			errChan <- nil
		}

		signal.Stop(c)
	}()

	errors.Check(server.Serve(ctx))
	close(exitChan)
	err = <-errChan

	return
}
