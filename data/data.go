// Package data provides utilities to query, merge and patch data of map[string]any.
package data

import (
	"bytes"
	"encoding/json"
	"math"
	"reflect"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/bytedance/sonic"
)

const defaultTagName = "data"

var emptyData Data

// Data is a general data storage structure that can be used to express data
// in various formats such as JSON, TOML, YAML, etc.
// It can also be used to serialize/deserialize Go struct.
//
// Data is not editable directly. It can only be modified by MergeTo, Patch#ApplyTo, etc.
type Data struct {
	data RawData
}

var (
	_ json.Marshaler   = Data{}
	_ json.Unmarshaler = &Data{}
)

// RawData represents raw data in Data.
type RawData map[string]any

// Make creates a new Data from the m.
// It filters out illegal data and converts struct inside the m to Data format.
//
// Make is suitable to convert map[string]any data generated by JSON/YAML deserialization tools.
// For general purpose, you should use Encoder instead.
func Make(m map[string]any) Data {
	enc := Encoder{}
	return enc.Encode(m)
}

// MarshalJSON marshals d into JSON.
func (d Data) MarshalJSON() ([]byte, error) {
	buf := &bytes.Buffer{}
	d.json(buf, false)
	return buf.Bytes(), nil
}

// UnmarshalJSON parses JSON string and sets d's value.
//
// We don't use `json.Unmarshal` to deserialize directly because `Data` requires all data types
// to be unified internally, but `json.Unmarshal` cannot meet this requirement.
func (d *Data) UnmarshalJSON(src []byte) error {
	data := RawData{}
	buf := bytes.NewBuffer(src)
	dec := sonic.ConfigDefault.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	*d = Make(data)
	return nil
}

// Query parses query and returns the value matching the query.
// If the value is not found, nil is returned.
//
// The syntax of query is a list of map keys separated by ".".
// For example, "a.b.c" represents d["a"]["b"]["c"].
// If you want to access array elements, you can write the array index directly,
// such as "a.0.c" represents d["a"][0]["c"].
//
// If map key contains ".", you can use "\" to escape it.
func (d Data) Query(query string) any {
	return d.data.Query(query)
}

// Query parses query and returns the value matching the query.
// If the value is not found, nil is returned.
//
// The syntax of query is a list of map keys separated by ".".
// For example, "a.b.c" represents d["a"]["b"]["c"].
// If you want to access array elements, you can write the array index directly,
// such as "a.0.c" represents d["a"][0]["c"].
//
// If map key contains ".", you can use "\" to escape it.
func (d RawData) Query(query string) any {
	if query == "" {
		return d
	}

	fields := parseQuery(query)
	return d.Get(fields...)
}

func parseQuery(query string) []string {
	if query == "" {
		return nil
	}

	var fields []string
	isEscaped := false
	field := &strings.Builder{}

	for len(query) > 0 {
		r, size := utf8.DecodeRuneInString(query)

		switch r {
		case '.':
			if isEscaped {
				field.WriteRune(r)
				isEscaped = false
			} else {
				fields = append(fields, field.String())
				field.Reset()
			}

		case '\\':
			if isEscaped {
				field.WriteRune(r)
				isEscaped = false
			} else {
				isEscaped = true
			}

		default:
			if isEscaped {
				field.WriteRune('\\')
				isEscaped = false
			}

			field.WriteRune(r)
		}

		query = query[size:]
	}

	if isEscaped {
		field.WriteRune('\\')
	}

	fields = append(fields, field.String())
	return fields
}

// Get returns value through the fields.
// It returns nil if the value is not found.
//
// The fields is an array of map indices.
// For example, []string{"a", "b", "c"} represents d["a"]["b"]["c"].
// If you want to access array elements, you can write the array index directly,
// such as []string{"a", "0", "c"} represents d["a"][0]["c"].
func (d Data) Get(fields ...string) any {
	return d.data.Get(fields...)
}

// Get returns value through the fields.
// It returns nil if the value is not found.
//
// The fields is an array of map indices.
// For example, []string{"a", "b", "c"} represents d["a"]["b"]["c"].
// If you want to access array elements, you can write the array index directly,
// such as []string{"a", "0", "c"} represents d["a"][0]["c"].
func (d RawData) Get(fields ...string) any {
	if len(fields) == 0 {
		return d
	}

	v := d.get(fields, nil)

	if !v.IsValid() {
		return nil
	}

	return v.Interface()
}

func (d RawData) get(fields []string, modifier func(v reflect.Value) reflect.Value) (found reflect.Value) {
	if len(fields) == 0 {
		found = reflect.ValueOf(d)

		if modifier != nil {
			found = modifier(found)
		}

		return
	}

	k := fields[0]
	fields = fields[1:]
	val := reflect.ValueOf(d).MapIndex(reflect.ValueOf(k))

	if !val.IsValid() || val.IsNil() {
		return
	}

	if len(fields) == 0 {
		if modifier != nil {
			val = modifier(val)

			if val.IsValid() {
				d[k] = val.Interface()
			} else {
				delete(d, k)
			}
		}

		found = val
		return
	}

	callModifier := func(i int, v reflect.Value) reflect.Value {
		if i == len(fields)-1 && modifier != nil {
			return modifier(v)
		}

		return v
	}

	for i, f := range fields {
		for val.Kind() == reflect.Interface {
			val = val.Elem()
		}

		switch val.Kind() {
		case reflect.Map:
			t := val.Type()
			kt := t.Key()

			switch kt.Kind() {
			case reflect.String:
				idx := reflect.ValueOf(f)
				kv := val.MapIndex(idx)

				if !kv.IsValid() {
					return
				}

				kv = callModifier(i, kv)
				val.SetMapIndex(idx, kv)
				val = kv

			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				n, err := strconv.ParseInt(f, 10, 64)

				if err != nil {
					return
				}

				idx := reflect.New(kt).Elem()

				if idx.OverflowInt(n) {
					return
				}

				idx.SetInt(n)
				kv := val.MapIndex(idx)

				if !kv.IsValid() {
					return
				}

				kv = callModifier(i, kv)
				val.SetMapIndex(idx, kv)
				val = kv

			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
				n, err := strconv.ParseUint(f, 10, 64)

				if err != nil {
					return
				}

				idx := reflect.New(kt).Elem()

				if idx.OverflowUint(n) {
					return
				}

				idx.SetUint(n)
				kv := val.MapIndex(idx)

				if !kv.IsValid() {
					return
				}

				kv = callModifier(i, kv)
				val.SetMapIndex(idx, kv)
				val = kv

			case reflect.Float32, reflect.Float64:
				fl, err := strconv.ParseFloat(f, 64)

				if err != nil {
					return
				}

				idx := reflect.New(kt).Elem()

				if idx.OverflowFloat(fl) {
					return
				}

				idx.SetFloat(fl)
				kv := val.MapIndex(idx)

				if !kv.IsValid() {
					return
				}

				kv = callModifier(i, kv)
				val.SetMapIndex(idx, kv)
				val = kv

			default:
				return
			}
		case reflect.Slice:
			n, err := strconv.ParseInt(f, 10, 64)

			if err != nil {
				return
			}

			if n < 0 || n > math.MaxInt32 {
				return
			}

			l := val.Len()
			idx := int(n)

			if idx >= l {
				return
			}

			kv := val.Index(idx)
			kv.Set(callModifier(i, kv))
			val = kv

		default:
			return
		}

		if !val.IsValid() {
			return
		}
	}

	found = val
	return
}

// Delete deletes the key matching any one of the queries.
// If one of the queries is an empty string, d is cleared completedly.
func (d *RawData) Delete(queries ...string) {
	// 如果需要清空 d，优先做这个处理，这样会更快一些。
	for _, query := range queries {
		if query == "" {
			*d = nil
			return
		}
	}

	for _, query := range queries {
		d.delete(query)
	}
}

func (d RawData) delete(query string) {
	fields := strings.Split(query, ".")
	target := fields[len(fields)-1] // The last key is the target.
	fields = fields[:len(fields)-1]

	d.get(fields, func(val reflect.Value) (v reflect.Value) {
		if target == "" {
			return
		}

		for val.Kind() == reflect.Interface {
			val = val.Elem()
		}

		v = val

		switch val.Kind() {
		case reflect.Map:
			if val.Type().AssignableTo(typeOfObject) {
				val.SetMapIndex(reflect.ValueOf(target), reflect.Value{})
			}

			v = val
		case reflect.Slice:
			idx, err := strconv.ParseInt(target, 10, 64)

			if err != nil {
				return
			}

			i := int(idx)
			l := val.Len()

			if i < 0 || i >= l {
				return
			}

			if i == l-1 {
				val.SetLen(l - 1)
				return
			}

			front := val.Slice(0, i)
			remaining := val.Slice(i+1, l)
			v = reflect.AppendSlice(front, remaining)
		}

		return
	})
}

// JSON returns a JSON string representing d.
// If the pretty is true, it will return a pretty-print JSON.
func (d Data) JSON(pretty bool) string {
	buf := &bytes.Buffer{}
	d.json(buf, pretty)
	return buf.String()
}

func (d Data) json(buf *bytes.Buffer, pretty bool) {
	if d.Len() == 0 {
		buf.WriteString("{}")
		return
	}

	enc := sonic.ConfigStd.NewEncoder(buf)
	enc.SetEscapeHTML(false)

	if pretty {
		enc.SetIndent("", "\t")
	}

	enc.Encode(d.data)

	// Remove redundant '\n'.
	data := buf.Bytes()

	if len(data) > 0 && data[len(data)-1] == '\n' {
		buf.Truncate(buf.Len() - 1)
	}
}

// String returns a JSON string representing d.
func (d Data) String() string {
	return d.JSON(false)
}

// Len returns the length of internal map data.
func (d Data) Len() int {
	return len(d.data)
}

// Clone creates a deep-copy of d.
func (d Data) Clone() Data {
	return Merge(d)
}
